# Global location lottery code for Global Citizens' Assembly - Civic Assembly 2025/6
#
# Original code: April 2020 by "Brett Hennig and ...." https://github.com/GlobalAssembly/global-select-app/blob/main/global-select-admin-centroids.py
# Adapted for the Global Citizens' Assembly's Civic Assembly 2025/26 by Johnny S-D
# Licensed under GNU General Public License v3.0 as per the original
# Main changes:
# 1. Random shuffle of all locations in combined database before picking people
# 2. Addition of climate risk bins as caps (see nd_gain_operations.py for how this is done and change what boost you might want to use)
# 3. Addition of option to ensure a certian number of countries from a certain list (implimented here for SIDS countries, but could be anything)
# 4. Addition of a minimum number of countries to ensure geographic diversity
# 5. Visualisations on maps and bar charts to check distribution and compliance with caps
# 6. Additional debugging printouts

# Note: this code was developed in Cursor with a Jupyter extention where it runs in an interactive window, so you might need to adjust the way figures are shown to get them to appear in a convenient manner, depending on your setup.

import csv, random, math
import pandas as pd
#for map making
import plotly.express as px
import plotly.graph_objects as go

# Settings/input

# must download data and put the path to it here
global_pop_admin_centroids_file_root = r"D:\YOUR_PATH\resources\gpw-v4-admin-unit-center-points-population-estimates-rev11_global_csv"
other_resources_file_path = r"D:\YOUR_PATH\resources"
global_pop_output_file_root = r"D:\YOUR_PATH\outputs"
global_pop_admin_centroids_files = [
		"gpw_v4_admin_unit_center_points_population_estimates_rev11_usa_midwest.csv",
		"gpw_v4_admin_unit_center_points_population_estimates_rev11_usa_northeast.csv",
		"gpw_v4_admin_unit_center_points_population_estimates_rev11_usa_south.csv",
		"gpw_v4_admin_unit_center_points_population_estimates_rev11_usa_west.csv",
		"gpw_v4_admin_unit_center_points_population_estimates_rev11_global.csv"
		]
# At the time of writing, the above files can be found at https://www.earthdata.nasa.gov/data/catalog/sedac-ciesin-sedac-gpwv4-aducppe-r11-4.11
# (click 'data access' then 'download' to get to the sight where you can find them in a very long list)
un_region_country_count_file = other_resources_file_path + "\\regions_countries_list_with_pop.csv"

# import climate risk boosts generated by nd_gain_operations.py
climate_risk_caps = pd.read_csv(other_resources_file_path + "\\boosted_data_boost_method_just_boost_the_first_bin_num_bins_4_bins_boosted_by1.5.csv") # replace this with your own bins created using nd_gain_operations.py 
print(climate_risk_caps.head())


# SIDS (Small Island Developing States) configuration - this same functionality could be used to prioritize any county group
ENABLE_SIDS_GUARANTEE = True  # Set to False to disable SIDS guarantee
SIDS_PERCENTAGE = 0.05  # 5% of initial selection will be from SIDS countries (but any with more than 1 will be reduced to 1) - aiming for up to 5% (= 5 or 6 out of 105)
SIDS_POPULATION_THRESHOLD = 2000000 # max population for the SIDS - inclusing because several SIDS countries are very large and systematically take seats away from latin america
SIDS_COUNTRIES_FILE = "sids_countries_and_codes.csv"  # File containing SIDS ISO3 codes

SAVE_FIGURES = False

# Random seed for reproducible results (set to None for truly random selection, or set to an integer for testing)
# WARNING: Using a fixed seed makes selection predictable - only use for testing!
RANDOM_SEED = None  # Set to an integer (e.g., 42) for reproducible testing

# Minimum number of countries to ensure geographic diversity
# Read the UN region country count file to determine threshold
un_region_df = pd.read_csv(un_region_country_count_file)
MIN_COUNTRY_PERCENTAGE = 30 # change the percentage here to balance how much larger country's quotas will be reduced
MIN_COUNTRIES_THRESHOLD = round(MIN_COUNTRY_PERCENTAGE / 100 * len(pd.unique(un_region_df['parent_country_code']))) 
print(f"Minimum countries threshold: {MIN_COUNTRIES_THRESHOLD} countries must be represented")

# Load SIDS countries if enabled
sids_countries = set()
if ENABLE_SIDS_GUARANTEE:
    try:
        sids_df = pd.read_csv(other_resources_file_path + "\\" + SIDS_COUNTRIES_FILE)
        if 'ISO3' in sids_df.columns:
            sids_countries = set(sids_df['ISO3'].str.strip())
        elif 'iso3' in sids_df.columns:
            sids_countries = set(sids_df['iso3'].str.strip())
        else:
            print(f"Warning: No ISO3 column found in {SIDS_COUNTRIES_FILE}")
            print(f"Available columns: {list(sids_df.columns)}")
            sids_countries = set()
        
        if sids_countries:
            print(f"Loaded {len(sids_countries)} SIDS countries: {sorted(list(sids_countries))[:10]}{'...' if len(sids_countries) > 10 else ''}")
        else:
            print("No SIDS countries loaded - SIDS guarantee will be disabled")
            ENABLE_SIDS_GUARANTEE = False
    except FileNotFoundError:
        print(f"Warning: SIDS countries file {SIDS_COUNTRIES_FILE} not found - SIDS guarantee will be disabled")
        ENABLE_SIDS_GUARANTEE = False
    except Exception as e:
        print(f"Error loading SIDS countries: {e} - SIDS guarantee will be disabled")
        ENABLE_SIDS_GUARANTEE = False



# count total pop according to 2020 centroids data
# this just counts the total pop - do this once then define as a constant below
"""
total_pop = 0
iso_country_dict = {} #set()
for file_name in global_pop_admin_centroids_files:
	print("Reading in: " + file_name)
	file_handle = open(global_pop_admin_centroids_file_root + "\\" + file_name, 'r')
	file_reader = csv.DictReader(file_handle)
	for row in file_reader:
		pop_row = int(row[ "UN_2020_E" ])
		pop_iso = row["ISOALPHA"]
		total_pop += pop_row
		if pop_iso in iso_country_dict:
			iso_country_dict[pop_iso] += pop_row
		else:
			iso_country_dict[pop_iso] = pop_row
	file_handle.close()
#out_file_google = open(google_out_file_name, "w")
#for k, val in iso_country_dict.items():
#	out_file_google.write( k + ',' + str(val) + '\n' )
#out_file_google.close()
print("Total (file) pop = {}".format(total_pop))
"""
total_pop = 7758177449
num_points = 105
debug_print = True




# output file:
google_out_file_name = global_pop_output_file_root + "\\global-assembly-points.csv"


def make_map(gca_people, title, color_col='un_region'):
	"""Create a map of the selected points"""
	# Convert the data to a format plotly can handle
	people_data = []
	for region in gca_people.regions.values():
		for country_vals in region.countries.values():
			for person in country_vals["country_people"]:
				people_data.append(person)
	
	if not people_data:
		print("No people data to plot!")
		return
	
	# Create DataFrame for plotting
	df = pd.DataFrame(people_data)
	
	# Create the map
	fig = px.scatter_geo(df, 
						 lat='latitude', 
						 lon='longitude', 
						 hover_name='name', 
						 color=color_col, 
						 projection='equal earth', #natural earth
						 title=title)
	
	fig.update_layout(
		title=title,
		geo=dict(
			showland=True,
			landcolor='rgb(243, 243, 243)',
			showocean=True,
			oceancolor='rgb(204, 229, 255)',
			showcountries=True,
			countrycolor='rgb(128, 128, 128)',
			showcoastlines=True,
			coastlinecolor='rgb(128, 128, 128)',
		)
	)
	
	if SAVE_FIGURES:
		fig.write_image(global_pop_output_file_root + title + ".png")
	
	fig.show()
	return fig

def make_initial_vs_backup_map(gca_people, gca_backups, title, highlight_sids=False):
	"""Create a map showing initial points (green) vs backup points (blue)"""
	
	# Collect initial points (first num_points)
	initial_data = []
	initial_count = 0
	for region in gca_people.regions.values():
		for country_vals in region.countries.values():
			for person in country_vals["country_people"]:
				if initial_count < num_points:
					person_copy = person.copy()
					person_copy['point_type'] = 'Initial Selection'
					# Add SIDS highlighting if enabled
					if highlight_sids and person.get('country_iso') in sids_countries:
						person_copy['point_type'] = 'SIDS Selection'
					initial_data.append(person_copy)
					initial_count += 1
				else:
					break
			if initial_count >= num_points:
				break
		if initial_count >= num_points:
			break
	
	# Collect backup points (randomly sampled from all available)
	backup_data = []
	all_backup_people = []
	for region in gca_backups.regions.values():
		for country_vals in region.countries.values():
			for person in country_vals["country_people"]:
				all_backup_people.append(person)

	# Use ALL backup points - no need to limit visualization
	for person in all_backup_people:
		person_copy = person.copy()
		person_copy['point_type'] = 'Backup Points'
		backup_data.append(person_copy)
	
	# Combine data
	all_data = initial_data + backup_data
	if not all_data:
		print("No data to plot!")
		return
	

	
	df = pd.DataFrame(all_data)
	
	# Create custom color map
	color_map = {
		'Initial Selection': 'green',
		'Backup Points': 'blue',
		'SIDS Selection': 'red'  # Highlight SIDS points in red
	}
	
	# Create the map
	fig = px.scatter_geo(df, 
						 lat='latitude', 
						 lon='longitude', 
						 hover_name='name', 
						 color='point_type',
						 opacity=0.5,
						 color_discrete_map=color_map,
						 projection='equal earth',
						 title=title)
	
	fig.update_layout(
		title=title,
		geo=dict(
			showland=True,
			landcolor='rgb(243, 243, 243)',
			showocean=True,
			oceancolor='rgb(204, 229, 255)',
			showcountries=True,
			countrycolor='rgb(128, 128, 128)',
			showcoastlines=True,
			coastlinecolor='rgb(128, 128, 128)',
		)
	)
	
	if SAVE_FIGURES:
		fig.write_image(global_pop_output_file_root + title + ".png")
	
	fig.show()
	return fig

def get_sids_countries_summary(gca_people, sids_countries):
	"""Get a summary of which SIDS countries were selected"""
	sids_summary = {}
	
	for region in gca_people.regions.values():
		for country_vals in region.countries.values():
			for person in country_vals["country_people"]:
				country_iso = person.get("country_iso")
				if country_iso in sids_countries:
					if country_iso not in sids_summary:
						sids_summary[country_iso] = {
							'country_name': person.get("country", country_iso),
							'count': 0,
							'people': []
						}
					sids_summary[country_iso]['count'] += 1
					sids_summary[country_iso]['people'].append(person)
	
	return sids_summary

def print_sids_countries_table(sids_summary_before, sids_summary_after, sids_countries):
	"""Print a table comparing SIDS countries before and after quota enforcement"""
	print("\n" + "="*80)
	print("SIDS COUNTRIES SELECTION - BEFORE vs AFTER QUOTA ENFORCEMENT")
	print("="*80)
	
	# Get all SIDS countries that were selected at any point
	all_selected_sids = set(sids_summary_before.keys()) | set(sids_summary_after.keys())
	
	if not all_selected_sids:
		print("No SIDS countries were selected.")
		return
	
	# Sort by country code for consistent display
	sorted_sids = sorted(all_selected_sids)
	
	# Print header
	print(f"{'Country':<8} {'Name':<25} {'Before':<8} {'After':<8} {'Change':<8} {'Status'}")
	print("-" * 80)
	
	for country_iso in sorted_sids:
		before_count = sids_summary_before.get(country_iso, {}).get('count', 0)
		after_count = sids_summary_after.get(country_iso, {}).get('count', 0)
		
		# Get country name from before or after data
		country_name = "Unknown"
		if country_iso in sids_summary_before and sids_summary_before[country_iso]['people']:
			country_name = sids_summary_before[country_iso]['people'][0].get('country', country_iso)
		elif country_iso in sids_summary_after and sids_summary_after[country_iso]['people']:
			country_name = sids_summary_after[country_iso]['people'][0].get('country', country_iso)
		
		# Truncate long country names
		if len(country_name) > 24:
			country_name = country_name[:21] + "..."
		
		change = after_count - before_count
		change_str = f"{change:+d}" if change != 0 else "0"
		
		# Determine status
		if before_count == 0 and after_count > 0:
			status = "Added"
		elif before_count > 0 and after_count == 0:
			status = "Removed"
		elif change > 0:
			status = "Increased"
		elif change < 0:
			status = "Decreased"
		else:
			status = "Unchanged"
		
		print(f"{country_iso:<8} {country_name:<25} {before_count:<8} {after_count:<8} {change_str:<8} {status}")
	
	# Print summary
	total_before = sum(s['count'] for s in sids_summary_before.values())
	total_after = sum(s['count'] for s in sids_summary_after.values())
	total_change = total_after - total_before
	
	print("-" * 80)
	change_str = f"{total_change:+d}" if total_change != 0 else "0"
	print(f"{'TOTAL':<8} {'':<25} {total_before:<8} {total_after:<8} {change_str:<8} {'Net Change'}")
	print("="*80)

def make_quota_charts(gca_people):
	"""Create bar charts showing quotas vs actual amounts for regions and countries"""
	
	# Region-level chart
	region_data = []
	for region_name, region in gca_people.regions.items():
		quota_max = math.ceil(region.region_pop_percent)
		actual_count = region.region_count
		# Use quota_max for percentage calculation to be consistent with the actual quota
		quota_percent = (quota_max / num_points) * 100
		actual_percent = (actual_count / num_points) * 100
		
		region_data.append({
			'Region': region_name,
			'Quota (%)': quota_percent,
			'Actual (%)': actual_percent,
			'Quota Max': quota_max,
			'Actual Count': actual_count
		})
	
	region_df = pd.DataFrame(region_data)
	
	# Create region chart
	fig1 = go.Figure()
	
	fig1.add_trace(go.Bar(
		name='Quota (%)',
		x=region_df['Region'],
		y=region_df['Quota (%)'],
		marker_color='lightblue',
		text=region_df['Quota Max'],
		textposition='auto',
		hovertemplate='<b>%{x}</b><br>Quota: %{y:.1f}% (%{text} people)<extra></extra>'
	))
	
	fig1.add_trace(go.Bar(
		name='Actual (%)',
		x=region_df['Region'],
		y=region_df['Actual (%)'],
		marker_color='orange',
		text=region_df['Actual Count'],
		textposition='auto',
		hovertemplate='<b>%{x}</b><br>Actual: %{y:.1f}% (%{text} people)<extra></extra>'
	))
	
	fig1.update_layout(
		title='UN Region Quotas vs Actual Selection (number on bar is number of people)',
		xaxis_title='UN Region',
		yaxis_title='Percentage of Total Points',
		barmode='group',
		height=500
	)

	if SAVE_FIGURES:
		fig1.write_image(global_pop_output_file_root + "region_quotas_chart.png")
	fig1.show()
	
	# Country-level chart (top 20 countries by quota)
	# First, collect and aggregate data for countries that appear in multiple regions
	country_aggregated = {}
	
	for region in gca_people.regions.values():
		for country_code, country_vals in region.countries.items():
			if country_vals["country_pc"] > 0:  # Only countries with quotas
				# Skip child countries - they're already included in parent country quotas
				parent_country = country_vals["parent_country_code"]
				if country_code != parent_country:
					if debug_print:
						print(f"Skipping child country: {country_code} is a child of {parent_country}")
					continue  # Skip child countries
				
				raw_quota = country_vals["country_pc"]  # Raw quota (could be fractional)
				actual_count = len(country_vals["country_people"])
				
				# Aggregate data for countries that appear in multiple regions
				if country_code in country_aggregated:
					country_aggregated[country_code]["raw_quota"] += raw_quota
					country_aggregated[country_code]["actual_count"] += actual_count
					if debug_print:
						print(f"Aggregating {country_code}: adding raw quota {raw_quota:.3f}, actual {actual_count}")
				else:
					country_aggregated[country_code] = {
						"raw_quota": raw_quota,
						"actual_count": actual_count
					}
					#if debug_print:
						#print(f"Adding country to chart: {country_code} (parent: {parent_country}) - raw quota: {raw_quota:.3f}, actual: {actual_count}")
	
	# Convert aggregated data to list for DataFrame
	country_data = []
	for country_code, data in country_aggregated.items():
		raw_quota = data["raw_quota"]
		quota_max = math.ceil(raw_quota)  # Round up the aggregated raw quota
		actual_count = data["actual_count"]
		# Use quota_max for percentage calculation to be consistent with the actual quota
		quota_percent = (quota_max / num_points) * 100
		actual_percent = (actual_count / num_points) * 100
		
		country_data.append({
			'Country': country_code,
			'Quota (%)': quota_percent,
			'Actual (%)': actual_percent,
			'Quota Max': quota_max,
			'Actual Count': actual_count
		})
	
	country_df = pd.DataFrame(country_data)
	# Sort by quota and take top 20
	country_df = country_df.sort_values('Quota (%)', ascending=False)#.head(20)
	
	# if debug_print:
	# 	print(f"\nCountries in chart DataFrame:")
	# 	for _, row in country_df.iterrows():
	# 		print(f"  {row['Country']}: quota={row['Quota Max']}, actual={row['Actual Count']}")
	# 	print(f"Total countries in chart: {len(country_df)}")
	
	# Create country chart
	fig2 = go.Figure()
	
	fig2.add_trace(go.Bar(
		name='Quota (%)',
		x=country_df['Country'],
		y=country_df['Quota (%)'],
		marker_color='lightgreen',
		text=country_df['Quota Max'],
		textposition='auto',
		hovertemplate='<b>%{x}</b><br>Quota: %{y:.1f}% (%{text} people)<extra></extra>'
	))
	
	fig2.add_trace(go.Bar(
		name='Actual (%)',
		x=country_df['Country'],
		y=country_df['Actual (%)'],
		marker_color='red',
		text=country_df['Actual Count'],
		textposition='auto',
		hovertemplate='<b>%{x}</b><br>Actual: %{y:.1f}% (%{text} people)<extra></extra>'
	))
	
	# Count countries with selected people
	countries_with_people = len(country_df[country_df['Actual Count'] > 0])
	
	fig2.update_layout(
		title='Top 20 Countries: Quotas vs Actual Selection (number on bar is number of people)',
		xaxis_title='Country Code',
		yaxis_title='Percentage of Total Points',
		barmode='group',
		height=600,
		xaxis={'tickangle': 45},
		annotations=[
			dict(
				x=0.98,
				y=0.98,
				xref='paper',
				yref='paper',
				text=f'Countries with selected people: {countries_with_people}/{MIN_COUNTRIES_THRESHOLD}',
				showarrow=False,
				font=dict(size=12, color='black'),
				bgcolor='rgba(255,255,255,0.8)',
				bordercolor='black',
				borderwidth=1,
				borderpad=4
			)
		]
	)
	
	fig2.show()
	
	# Climate risk bin chart
	climate_data = []
	for bin_name, bin_obj in gca_people.climate_risk_bins.items():
		# Handle the "None" bin specially (no quota limit)
		if bin_name == "Climate Risk Bin None":
			quota_percent = 0  # No quota percentage
			quota_max_str = "No Limit"
		else:
			# Use the actual quota_max for percentage calculation to be consistent
			quota_percent = (bin_obj.quota_max / num_points) * 100
			quota_max_str = bin_obj.quota_max
		
		actual_percent = (bin_obj.actual_count / num_points) * 100
		
		climate_data.append({
			'Bin': bin_name,
			'Quota (%)': quota_percent,
			'Actual (%)': actual_percent,
			'Quota Max': quota_max_str,
			'Actual Count': bin_obj.actual_count
		})
	
	climate_df = pd.DataFrame(climate_data)
	
	# Create climate risk chart
	fig3 = go.Figure()
	
	fig3.add_trace(go.Bar(
		name='Quota (%)',
		x=climate_df['Bin'],
		y=climate_df['Quota (%)'],
		marker_color='lightcoral',
		text=climate_df['Quota Max'],
		textposition='auto',
		hovertemplate='<b>%{x}</b><br>Quota: %{y:.1f}% (%{text})<extra></extra>'
	))
	
	fig3.add_trace(go.Bar(
		name='Actual (%)',
		x=climate_df['Bin'],
		y=climate_df['Actual (%)'],
		marker_color='purple',
		text=climate_df['Actual Count'],
		textposition='auto',
		hovertemplate='<b>%{x}</b><br>Actual: %{y:.1f}% (%{text} people)<extra></extra>'
	))
	
	fig3.update_layout(
		title='Climate Risk Bin Quotas vs Actual Selection (number on bar is number of people)',
		xaxis_title='Climate Risk Bin',
		yaxis_title='Percentage of Total Points',
		barmode='group',
		height=500
	)
	
	fig3.show()
	
	return fig1, fig2, fig3


# Climate risk bin class for managing climate risk quotas
class climate_risk_bin():
	def __init__(self, bin_name, quota_proportion):
		self.bin_name = bin_name
		self.quota_proportion = quota_proportion  # 0-1, not percentage
		self.quota_max = math.ceil(quota_proportion * num_points)
		self.actual_count = 0
		self.countries_in_bin = set()  # Set of country codes in this bin
		self.bin_people = []
		
	def add_country_to_bin(self, country_code):
		"""Add a country to this climate risk bin"""
		self.countries_in_bin.add(country_code)
		
	def add_person_to_bin(self, person):
		"""Add a person to this bin if their country belongs here"""
		if person["country_iso"] in self.countries_in_bin:
			self.actual_count += 1
			person["climate_risk_bin"] = self.bin_name  # Set the bin name
			self.bin_people.append(person)
			return True
		return False
		
	def delete_above_max(self):
		"""Delete people above the quota maximum"""
		if self.actual_count > self.quota_max:
			num_to_delete = self.actual_count - self.quota_max
			if debug_print:
				print(f"Climate risk bin {self.bin_name} above max, delete {num_to_delete}")
			# Randomly select people to delete
			to_delete = set(random.sample(range(self.actual_count), num_to_delete))
			self.bin_people = [x for i, x in enumerate(self.bin_people) if i not in to_delete]
			self.actual_count -= num_to_delete
			return num_to_delete
		return 0
		
	def replacement(self, person):
		"""Try to replace a deleted person with someone from this bin"""
		if self.actual_count < self.quota_max and person["country_iso"] in self.countries_in_bin:
			self.bin_people.append(person)
			self.actual_count += 1
			return 1
		return 0
		
	def write_bin_summary(self, out_file):
		"""Write summary of this bin's quota vs actual"""
		out_file.write(f"{self.bin_name},{self.quota_max},{self.actual_count}\n")
		
	def get_person(self, x):
		"""Get person at index x from this bin"""
		if 0 <= x < self.actual_count:
			return self.bin_people[x]
		return None

# from https://en.wikipedia.org/wiki/United_Nations_Regional_Groups
class un_region():
	def __init__(self, region_name ):
		self.region_name = region_name
		self.region_pop_percent = 0.0 # actually num_points fraction / 100
		self.region_count = 0
		self.countries = {}
		
	def add_country_to_region(self, country_code, parent_country_code, country_pc):
		if country_code in self.countries:
			print("ERROR: Two rows with same country code: {}".format(country_code))
		
		# Handle parent country logic more robustly
		if parent_country_code != country_code:
			# Check if parent country exists, if not create it with 0 population
			if parent_country_code not in self.countries:
				if debug_print:
					print(f"Creating missing parent country: {parent_country_code} for {country_code}")
				self.countries[parent_country_code] = { 
					"parent_country_code": parent_country_code, 
					"country_pc": 0, 
					"country_people": [] 
				}
			# Add this country's population to parent
			self.countries[parent_country_code]["country_pc"] += country_pc
		
		# Add the current country
		self.countries[country_code] = { 
			"parent_country_code": parent_country_code, 
			"country_pc": country_pc, 
			"country_people": [] 
		}
		self.region_pop_percent += country_pc
	
	def add_person_to_region(self, person):
		self.region_count += 1
		# check if this "country" has a parent, if so make the country be the parent
		parent_country = self.countries[ person["country_iso"] ]["parent_country_code"]
		if person["country_iso"] != parent_country:
			if debug_print:
				print("Found parent country of {} and set to {}.".format(person["country_iso"], parent_country))
			person["country_iso"] = parent_country
		self.countries[ person["country_iso"] ][ "country_people" ].append( person )
		
	def write_country_summary(self, out_file_google):
		for country_key, country_vals in self.countries.items():
			country_count = len(country_vals[ "country_people" ])
			country_max = math.ceil(country_vals["country_pc"])
			if country_count != 0:
				out_file_google.write( country_key + "," + str(country_max) + "," + str(country_count) + "\n" )
		max_region_count = math.ceil(self.region_pop_percent)
		return self.region_name + "," + str(max_region_count) + "," + str(self.region_count) + "\n"
		
	def write_people(self):
		people_array = []
		for country_vals in self.countries.values():
			for person in country_vals["country_people"]:
				# Clean any commas in the data to prevent CSV parsing issues
				cleaned_values = []
				for x in person.values():
					cleaned_value = str(x).replace(',', '-')  # Replace commas with dashes
					cleaned_values.append(cleaned_value)
				people_array.append( ",".join(cleaned_values) + "\n" )
		return people_array
		
	def delete_above_max(self):
		# first check country maxs
		num_deleted = 0
		for country_key, country_vals in self.countries.items():
			country_count = len(country_vals[ "country_people" ])
			country_max = math.ceil(country_vals["country_pc"])
			if country_count > country_max:
				#print(country_count)
				num_to_delete = country_count - country_max
				if debug_print:
					print("Country {} above max, delete {}".format(country_key, num_to_delete))
				# delete num_to_delete
				# chose who to delete
				to_delete = set(random.sample(range(country_count), num_to_delete))
				# delete them
				country_vals[ "country_people" ] = [x for i,x in enumerate(country_vals[ "country_people" ]) if not i in to_delete]
				num_deleted += num_to_delete
				self.region_count -= num_to_delete
		max_region_count = math.ceil(self.region_pop_percent)
		if self.region_count > max_region_count:
			num_to_delete = self.region_count - max_region_count
			if debug_print:
				print("Region {} above max, delete {}".format(self.region_name, num_to_delete))
			# delete num_to_delete
			to_delete = set(random.sample(range(self.region_count), num_to_delete))
			for country_key, country_vals in self.countries.items():
				orig_len = len(country_vals[ "country_people" ])
				country_vals[ "country_people" ] = [x for i,x in enumerate(country_vals[ "country_people" ]) if not i in to_delete]
				# if the numbers to delete were 2, 7, 11 and the first country had 3 people then we delete person 2,
				# then shift the numbers down 3 to: -1, 4, 8 and look in the next country etc
				to_delete = [x - orig_len for x in to_delete]
			num_deleted += num_to_delete
			self.region_count -= num_to_delete
		return num_deleted
	
	def replacement( self, person ):
		max_region_count = math.ceil(self.region_pop_percent)
		if self.region_count < max_region_count:
			country_code = self.countries[ person["country_iso"] ][ "parent_country_code" ]
			if country_code != person["country_iso"]: # there is a parent country
				person["country_iso"] = country_code
			country = self.countries[ country_code ]
			country_max = math.ceil(country[ "country_pc" ])
			if len(country[ "country_people" ]) < country_max:
				country[ "country_people" ].append(person)
				self.region_count += 1
				return 1
			else:
				#print("failed to replace in {} as {} of {}".format(person["country_iso"], len(country[ "country_people" ]), country[ "country_max" ]))
				return 0
		else:
			#print("failed to replace in {} as {} of {}".format(self.region_name, self.region_count, self.max_region_count))
			return 0

	def get_person(self, x):
		total_country_count = 0
		for country_key, country_vals in self.countries.items():
			country_count = len(country_vals[ "country_people" ])
			if x >= total_country_count and x < total_country_count + country_count:
				return country_vals[ "country_people" ][x - total_country_count]
			total_country_count += country_count
		print("Error - got to country list end {}".format(x))
		
		
class ca_people():
	name_fields = ["NAME1", "NAME2", "NAME3", "NAME4", "NAME5", "NAME6"]
	total_pop = 0

	def __init__(self, total_pop, num_points, print_info):
		ca_people.total_pop = total_pop
		self.num_points = num_points
		self.print_info = print_info
		self.regions = {
			"Africa Group" : un_region("Africa Group" ),
			"Asia and the Pacific Group" : un_region("Asia and the Pacific Group" ),
			"Eastern European Group" : un_region("Eastern European Group" ),
			"Latin American and Caribbean Group" : un_region("Latin American and Caribbean Group" ),
			"Western European and Others Group" : un_region("Western European and Others Group" )  }
		
		# Initialize climate risk bins from the imported data
		self.climate_risk_bins = {}
		if print_info:
			print("Setting up climate risk bins...")
		
		# Take all rows except the last one (which contains NaN values)
		num_rows = len(climate_risk_caps)
		for i, row in climate_risk_caps.head(num_rows - 1).iterrows():
			bin_name = f"Climate Risk Bin {i+1}"
			quota_proportion = row['boosted_counts']  # This is 0-1, not percentage
			bin_obj = climate_risk_bin(bin_name, quota_proportion)
			
			# Parse the countries in this bin
			countries_str = row['countries_in_bin_ISO3']
			if isinstance(countries_str, str):
				# Handle different possible formats (comma-separated, space-separated, etc.)
				# Remove brackets, split by comma, then clean each country code
				countries = [c.strip().strip("'").strip('"').strip() for c in countries_str.replace('[', '').replace(']', '').split(',')]
				for country in countries:
					if country:  # Skip empty strings
						bin_obj.add_country_to_bin(country)
						if debug_print:
							print(f"    Added {country} to {bin_name}")
			
			self.climate_risk_bins[bin_name] = bin_obj
			
			if print_info:
				print(f"  {bin_name}: {len(bin_obj.countries_in_bin)} countries, quota: {quota_proportion:.3f} ({bin_obj.quota_max} people)")
				if debug_print:
					print(f"    Countries: {sorted(list(bin_obj.countries_in_bin))}")
		
		# Add a "None" bin for countries not in the climate risk dataset (no quota limitations)
		none_bin = climate_risk_bin("Climate Risk Bin None", 0.0)  # 0 quota proportion = no limit
		none_bin.quota_max = float('inf')  # No quota limit
		self.climate_risk_bins["Climate Risk Bin None"] = none_bin
		
		if print_info:
			print(f"  Climate Risk Bin None: No quota limit (for countries not in climate risk dataset)")
			print("Total population in database = {}".format(ca_people.total_pop))
			
		# Debug: Check for country code mismatches
		if debug_print:
			print("\nChecking for potential country code mismatches...")
			climate_countries = set()
			for bin_name, bin_obj in self.climate_risk_bins.items():
				climate_countries.update(bin_obj.countries_in_bin)
			
			print(f"Total unique countries in climate risk bins: {len(climate_countries)}")
			print(f"Sample climate risk countries: {sorted(list(climate_countries))[:10]}")
			
			# Check if any of these countries appear in the GPW data
			gpw_countries = set()
			for region in self.regions.values():
				gpw_countries.update(region.countries.keys())
			
			print(f"Total unique countries in GPW data: {len(gpw_countries)}")
			print(f"Sample GPW countries: {sorted(list(gpw_countries))[:10]}")
			
			# Find intersection
			common_countries = climate_countries.intersection(gpw_countries)
			print(f"Countries in both datasets: {len(common_countries)}")
			if len(common_countries) < len(climate_countries):
				missing_countries = climate_countries - gpw_countries
				print(f"Countries in climate risk data but not in GPW data: {sorted(list(missing_countries))[:10]}")
				if len(missing_countries) > 10:
					print(f"... and {len(missing_countries) - 10} more")
		# Use the already loaded region and country data
		# Convert DataFrame to list of dictionaries and sort them to ensure parent countries come before territories
		all_rows = un_region_df.to_dict('records')
		# Sort by parent_country_code first, then by country_code
		# This ensures FRA is processed before GUF, etc.
		all_rows.sort(key=lambda x: (x["parent_country_code"], x["country_code"]))

		if print_info:
			print(f"Processing {len(all_rows)} countries/territories...")
			print("First few rows after sorting:")
			for i, row in enumerate(all_rows[:5]):
				print(f"  {i+1}: {row['country_code']} -> {row['parent_country_code']} ({row['un_region']})")

		self.country_region = {}
		for row in all_rows:
			#country_max = math.ceil(float(row["country_pop_percent"]))
			country_percent = float(row["country_pop_percent"])
			#if country_max == 0: #check if rounding errors have crept in
			#	country_max = 1
			if print_info and debug_print:
				print(f"Adding {row['country_code']} (parent: {row['parent_country_code']}) to {row['un_region']}")
			self.regions[ row["un_region"] ].add_country_to_region( row["country_code"], row["parent_country_code"], num_points*country_percent/100.0 )
			self.country_region[row["country_code"]] = row["un_region"]

		# Select num_points points - population/density weighted?
		self.selected_nums = []
		# grab same number of backups as well - could be the same!
		for i in range(self.num_points):
			self.selected_nums.append(random.randint(1, ca_people.total_pop))

		if print_info:
			print("Randomly selected {} numbers from total population.".format(len(self.selected_nums)))
		self.selected_nums.sort()		
		self.count_selected_people = 0


	def grab_people_in_admin_area(self, pop_count, row):
		pop_row = int(row[ "UN_2020_E" ])
		while self.count_selected_people < self.num_points and self.selected_nums[self.count_selected_people] > pop_count and self.selected_nums[self.count_selected_people] <= pop_count + pop_row:
			#found a person we want!
			#print(selected_list_count, people_nums[selected_list_count], total_pop, total_pop + pop_row)
			place_name = ''
			for nm in ca_people.name_fields:
				if row[ nm ] != "NA" and row[ nm ] is not None:
					# Convert to string and handle both string and numeric values
					field_value = str(row[nm]).strip()
					if field_value and field_value != "NA" and field_value != "nan":
						if place_name != '':
							place_name += ' -- '
						place_name += field_value
			place_country = str(row["COUNTRYNM"]).strip()
			place_country_iso = row["ISOALPHA"]
			if self.print_info:
				print("                                           ", end="\r")
				print("Found point {} in {}".format(self.count_selected_people + 1, place_country))
			# throw a random offset into location based on its size, approximate as circle!
			orig_radius = math.sqrt(float(row["TOTAL_A_KM"])/math.pi)
			rand_radius_km = random.random()*orig_radius
			
			rrr = (math.pi/(180*60))*1000*rand_radius_km/1852.0
			tc = random.random()*2*math.pi
			lat1 = math.radians(float(row["CENTROID_Y"]))
			lon1 = math.radians(float(row["CENTROID_X"]))
			lat2 = math.asin(math.sin(lat1)*math.cos(rrr)+math.cos(lat1)*math.sin(rrr)*math.cos(tc))
			lon2 = (lon1-math.asin(math.sin(tc)*math.sin(rrr)/math.cos(lat2))+math.pi)%(2*math.pi) - math.pi
			rand_lat_deg = math.degrees(lat2)
			rand_lon_deg = math.degrees(lon2)
			# add to counts for country and region
			if place_country_iso in self.country_region.keys():
				person_region = self.country_region[place_country_iso]
			else:
				if debug_print:
					print("Error {} not in country-region map. ADDED TO 'Asia and the Pacific Group'".format(place_country_iso))
				person_region = "Asia and the Pacific Group"
				self.regions[ person_region ].add_country_to_region( place_country_iso, place_country_iso, 1 )
				self.country_region[place_country_iso] = person_region
			person = { "latitude" : rand_lat_deg,
					"longitude" : rand_lon_deg,
					"name" : place_name,
					"country" : place_country,
					"country_iso" : place_country_iso,
					"un_region" : person_region,
					"climate_risk_bin" : "None" }  # Will be set when added to bin
			
			# Store original country code for climate risk bin assignment
			original_country_iso = person["country_iso"]
			
			# Add person to region (this may modify the country_iso to parent country)
			self.regions[ person_region ].add_person_to_region( person )
			
			# Add person to appropriate climate risk bin using original country code
			bin_assigned = False
			for bin_name, bin_obj in self.climate_risk_bins.items():
				# Skip the "None" bin for now, try specific bins first
				if bin_name == "Climate Risk Bin None":
					continue
				# Use original country code for climate risk bin assignment
				if original_country_iso in bin_obj.countries_in_bin:
					bin_obj.actual_count += 1
					person["climate_risk_bin"] = bin_name  # Set the bin name
					bin_obj.bin_people.append(person)
					bin_assigned = True
					#if debug_print:
						#print(f"Assigned {original_country_iso} to {bin_name} (debug: bin_name type={type(bin_name)}, value='{bin_name}')")
					break  # Person was added to a bin, no need to check others
			
			# If not assigned to any specific bin, assign to "None" bin
			if not bin_assigned:
				none_bin = self.climate_risk_bins["Climate Risk Bin None"]
				none_bin.actual_count += 1
				person["climate_risk_bin"] = "Climate Risk Bin None"
				none_bin.bin_people.append(person)
				if debug_print:
					print(f"Assigned {original_country_iso} ({person['country']}) to Climate Risk Bin None (not in climate risk dataset)")
			
			self.count_selected_people += 1
			
		
	def selected_people_print(self):
		# output them for google map input
		# let's randomise the order here!   
		out_file_google = open(google_out_file_name, "w")
		file_output = "latitude, longitude, name, country, country_iso, un_region\n"
		people_array = []
		for region in self.regions.values():
			people_array += region.write_people()
		random.shuffle(people_array)
		file_output += "".join(people_array)
		  #Write to file
		people_array_str = ''.join([str(elem+'___') for elem in people_array])
		file = open("results.txt", "w")
		file.write(people_array_str)
		file.close()

		out_file_google.write( file_output )
		#out_file_google.write("Average minimum distance between points = {}\n".format(self.average_dist))
		# print country and region counts as well...
		out_file_google.write("country_iso, country_max, country_count\n")
		region_summary = ''
		for region in self.regions.values():
			region_summary += region.write_country_summary( out_file_google )
		out_file_google.write( "region_name, region_max, region_count\n" + region_summary )
		
		# Add climate risk bin summary
		out_file_google.write("climate_risk_bin, bin_max, bin_count\n")
		for bin_name, bin_obj in self.climate_risk_bins.items():
			out_file_google.write(f"{bin_name},{bin_obj.quota_max},{bin_obj.actual_count}\n")
		
		out_file_google.close()
	
	def get_person(self, x):
		# First check if we have reusable people
		if hasattr(self, 'reusable_people') and x < len(self.reusable_people):
			return self.reusable_people[x]
		
		# Adjust index for original backup pool
		original_index = x
		if hasattr(self, 'reusable_people'):
			original_index = x - len(self.reusable_people)
		
		# If we're asking for a reusable person, return it
		if original_index < 0:
			return None
		
		# Otherwise, get from original backup pool
		total_region_count = 0
		for region in self.regions.values():
			if original_index >= total_region_count and original_index < total_region_count + region.region_count:
				return region.get_person( original_index - total_region_count )
			total_region_count += region.region_count
		if debug_print:
			print("Error - got to region list end {}".format(original_index))
	
	def add_person_to_backup(self, person):
		"""Add a person back to the backup pool for potential reuse"""
		# Store the person in a separate list for reuse
		if not hasattr(self, 'reusable_people'):
			self.reusable_people = []
		self.reusable_people.append(person)
		self.num_points += 1
	
	def replace_above_max(self, gca_backups):
		"""Enforce all quota systems and replace excess people"""
		
		# Phase 1: Enforce country quotas
		print("\n=== PHASE 1: Country Quota Enforcement ===")
		self._enforce_country_quotas(gca_backups)
		print(f"Total people after Phase 1: {self.count_selected_people}")
		self._verify_total_count("Phase 1")
		
		# Phase 2: Enforce minimum countries threshold (early for diversity)
		print("\n=== PHASE 2: Minimum Countries Enforcement ===")
		self._verify_total_count("Before Phase 2")
		self.enforce_minimum_countries(gca_backups)
		print(f"Total people after Phase 2: {self.count_selected_people}")
		self._verify_total_count("Phase 2")
		
		# Phase 3: Enforce region quotas
		print("\n=== PHASE 3: Region Quota Enforcement ===")
		self._verify_total_count("Before Phase 3")
		self._enforce_region_quotas(gca_backups)
		print(f"Total people after Phase 3: {self.count_selected_people}")
		self._verify_total_count("Phase 3")
		
		# Phase 4: Enforce climate risk bin quotas
		print("\n=== PHASE 4: Climate Risk Bin Enforcement ===")
		self._verify_total_count("Before Phase 4")
		self._enforce_climate_risk_quotas(gca_backups)
		print(f"Total people after Phase 4: {self.count_selected_people}")
		self._verify_total_count("Phase 4")
		
		# Phase 5: Balance China and India representation (LAST - after all other quotas)
		print("\n=== PHASE 5: China-India Balance Enforcement ===")
		self._verify_total_count("Before Phase 5")
		self.enforce_china_india_balance(gca_backups)
		print(f"Total people after Phase 5: {self.count_selected_people}")
		self._verify_total_count("Phase 5")
	
	def _enforce_country_quotas(self, gca_backups):
		"""Enforce country-level quotas"""
		people_to_remove = []
		
		print(f"Starting country quota enforcement with {self.count_selected_people} people")
		self._verify_total_count("Before Phase 1")
		
		for region_name, region in self.regions.items():
			for country_code, country_vals in region.countries.items():
				country_count = len(country_vals["country_people"])
				country_max = math.ceil(country_vals["country_pc"])
				
				if country_count > country_max:
					excess = country_count - country_max
					print(f"Country {country_code} above max: {country_count} > {country_max}, removing {excess}")
					
					# Safety check: ensure we don't try to sample more than available
					if len(country_vals["country_people"]) < excess:
						print(f"Warning: Only {len(country_vals['country_people'])} people available in country {country_code}, but need to remove {excess}. Adjusting.")
						excess = len(country_vals["country_people"])
					
					if excess > 0:
						# Randomly select people to remove
						to_remove = random.sample(country_vals["country_people"], excess)
						people_to_remove.extend(to_remove)
		
		print(f"Total people to remove: {len(people_to_remove)}")
		
		# Remove people and replace
		if people_to_remove:
			self._remove_and_replace_people(people_to_remove, gca_backups, "country quota")
		
		print(f"After country quota enforcement: {self.count_selected_people} people")
		self._verify_total_count("Phase 1")
	
	def _enforce_region_quotas(self, gca_backups):
		"""Enforce region-level quotas"""
		people_to_remove = []
		
		for region_name, region in self.regions.items():
			region_max = math.ceil(region.region_pop_percent)
			if region.region_count > region_max:
				excess = region.region_count - region_max
				if debug_print:
					print(f"Region {region_name} above max: {region.region_count} > {region_max}, removing {excess}")
				
				# Randomly select people to remove from region
				all_region_people = []
				for country_vals in region.countries.values():
					all_region_people.extend(country_vals["country_people"])
				
				# Safety check: ensure we don't try to sample more than available
				if len(all_region_people) < excess:
					if debug_print:
						print(f"Warning: Only {len(all_region_people)} people available in region {region_name}, but need to remove {excess}. Adjusting.")
					excess = len(all_region_people)
				
				if excess > 0:
					to_remove = random.sample(all_region_people, excess)
					people_to_remove.extend(to_remove)
		
		# Remove people and replace
		if people_to_remove:
			self._remove_and_replace_people(people_to_remove, gca_backups, "region quota")
	
	def _enforce_climate_risk_quotas(self, gca_backups):
		"""Enforce climate risk bin quotas"""
		people_to_remove = []
		
		for bin_name, bin_obj in self.climate_risk_bins.items():
			# Skip the "None" bin as it has no quota limitations
			if bin_name == "Climate Risk Bin None":
				continue
			if bin_obj.actual_count > bin_obj.quota_max:
				excess = bin_obj.actual_count - bin_obj.quota_max
				if debug_print:
					print(f"Climate risk bin {bin_name} above max: {bin_obj.actual_count} > {bin_obj.quota_max}, removing {excess}")
				
				# Safety check: ensure we don't try to sample more than available
				if len(bin_obj.bin_people) < excess:
					if debug_print:
						print(f"Warning: Only {len(bin_obj.bin_people)} people available in bin {bin_name}, but need to remove {excess}. Adjusting.")
					excess = len(bin_obj.bin_people)
				
				if excess > 0:
					# Randomly select people to remove
					to_remove = random.sample(bin_obj.bin_people, excess)
					people_to_remove.extend(to_remove)
		
		# Remove people and replace
		if people_to_remove:
			self._remove_and_replace_people(people_to_remove, gca_backups, "climate risk quota")
	
	def _remove_and_replace_people(self, people_to_remove, gca_backups, reason):
		"""Remove people from all systems and replace them from backup pool"""
		
		# Remove duplicates while preserving order
		unique_people_to_remove = []
		seen_people = set()
		for person in people_to_remove:
			# Create a unique identifier for each person
			person_id = (person["latitude"], person["longitude"], person["country_iso"])
			if person_id not in seen_people:
				seen_people.add(person_id)
				unique_people_to_remove.append(person)
		
		total_to_remove = len(unique_people_to_remove)
		print(f"Removing {total_to_remove} people due to {reason}")
		
		if total_to_remove == 0:
			print(f"No {reason} violations found")
			return
		
		# Remove people from all systems and add to backup pool
		for person in unique_people_to_remove:
			self._remove_person_from_all_tracking(person, gca_backups)
		
		# Now replace people from backup pool
		replacements = list(range(gca_backups.num_points))
		random.shuffle(replacements)
		success_replace = 0
		
		print(f"Attempting to replace {total_to_remove} people from backup pool of {gca_backups.num_points}")
		
		for x in replacements:
			if success_replace >= total_to_remove:
				break
				
			person = gca_backups.get_person(x)
			if person is None:
				continue
			
			# Try to add this person to both systems
			can_add_to_region = False
			can_add_to_bin = False
			
			# Check if we can add to UN region
			if person["country_iso"] in self.country_region:
				person_region = self.country_region[person["country_iso"]]
				region = self.regions[person_region]
				
				# Check country quota
				country_vals = region.countries[person["country_iso"]]
				country_max = math.ceil(country_vals["country_pc"])
				country_count = len(country_vals["country_people"])
				
				# Check region quota
				region_max = math.ceil(region.region_pop_percent)
				
				# Check country and region quotas
				if country_count < country_max and region.region_count < region_max:
					can_add_to_region = True
			
			# Check if we can add to climate risk bin
			for bin_name, bin_obj in self.climate_risk_bins.items():
				if person["country_iso"] in bin_obj.countries_in_bin and bin_obj.actual_count < bin_obj.quota_max:
					can_add_to_bin = True
					break
			
			# Only add if both systems can accommodate
			if can_add_to_region and can_add_to_bin:
				# Use the proper method to add person to all tracking systems
				self._add_person_to_selection(person)
				
				success_replace += 1
				print(f"Replaced point {success_replace}/{total_to_remove} with {person['country']} ({person['country_iso']})")
			else:
				if debug_print:
					print(f"Cannot add {person['country']} ({person['country_iso']}): region={can_add_to_region}, bin={can_add_to_bin}")
		
		print(f"Successfully replaced {success_replace} out of {total_to_remove} people")
		if success_replace < total_to_remove:
			remaining_to_replace = total_to_remove - success_replace
			print(f"Could not replace {remaining_to_replace} people due to climate risk bin constraints")
			print(f"Attempting fallback: adding people from countries with 0 people in under-quota regions...")
			
			# Fallback strategy: add people from countries with 0 people in under-quota regions
			fallback_added = 0
			fallback_indices = list(range(gca_backups.num_points))
			random.shuffle(fallback_indices)
			
			# Get countries with 0 people
			countries_with_zero = set()
			for region in self.regions.values():
				for country_code, country_vals in region.countries.items():
					if len(country_vals["country_people"]) == 0:
						countries_with_zero.add(country_code)
			
			# Get regions that are under quota
			under_quota_regions = set()
			for region_name, region in self.regions.items():
				region_max = math.ceil(region.region_pop_percent)
				if region.region_count < region_max:
					under_quota_regions.add(region_name)
			
			print(f"Countries with 0 people: {len(countries_with_zero)}")
			print(f"Regions under quota: {len(under_quota_regions)}")
			
			for x in fallback_indices:
				if fallback_added >= remaining_to_replace:
					break
					
				person = gca_backups.get_person(x)
				if person is None:
					continue
				
				# Check if this person is from a country with 0 people and region under quota
				if (person["country_iso"] in countries_with_zero and 
					person["country_iso"] in self.country_region and
					self.country_region[person["country_iso"]] in under_quota_regions):
					
					# Check country quota only (ignore other constraints for diversity)
					person_region = self.country_region[person["country_iso"]]
					region = self.regions[person_region]
					country_vals = region.countries[person["country_iso"]]
					country_max = math.ceil(country_vals["country_pc"])
					country_count = len(country_vals["country_people"])
					
					if country_count < country_max:
						# Add this person (ignore climate risk bin constraints for diversity)
						self._add_person_to_selection(person)
						fallback_added += 1
						print(f"Fallback added {fallback_added}/{remaining_to_replace}: {person['country']} ({person['country_iso']})")
			
			total_replaced = success_replace + fallback_added
			print(f"Total replacements: {success_replace} (climate risk bin) + {fallback_added} (diversity fallback) = {total_replaced}/{total_to_remove}")
			if total_replaced < total_to_remove:
				still_lost = total_to_remove - total_replaced
				print(f"Still lost {still_lost} people - no suitable replacements found")
				print(f"Final total: {self.count_selected_people} people")
	
	def enforce_minimum_countries(self, gca_backups):
		"""Ensure minimum number of countries are represented by weighted replacement"""
		
		# Count current countries with people
		countries_with_people = set()
		for region in self.regions.values():
			for country_code, country_vals in region.countries.items():
				if len(country_vals["country_people"]) > 0:
					countries_with_people.add(country_code)
		
		current_countries = len(countries_with_people)
		print(f"Current countries with people: {current_countries}")
		
		if current_countries >= MIN_COUNTRIES_THRESHOLD:
			print(f"Minimum countries threshold ({MIN_COUNTRIES_THRESHOLD}) already satisfied")
			return
		
		countries_needed = MIN_COUNTRIES_THRESHOLD - current_countries
		print(f"Need {countries_needed} more countries to reach minimum threshold of {MIN_COUNTRIES_THRESHOLD}")
		
		# Collect all removable people (from countries with >1 person AND above half quota)
		all_removable_people = []
		for region in self.regions.values():
			for country_code, country_vals in region.countries.items():
				country_count = len(country_vals["country_people"])
				country_quota = math.ceil(country_vals["country_pc"])
				half_quota = math.ceil(country_quota / 2)  # At least half of quota (rounded up)
				
				# Only consider countries that have >1 person AND are above half their quota
				if country_count > 1 and country_count > half_quota:
					# Calculate how many people can be removed (down to half quota)
					max_removable = country_count - half_quota
					# Add only the removable people
					removable_people = country_vals["country_people"][:max_removable]
					all_removable_people.extend(removable_people)
					
					if debug_print:
						print(f"Country {country_code}: {country_count} people, quota {country_quota}, half_quota {half_quota}, can remove {max_removable}")
		
		if not all_removable_people:
			print("No countries with >1 person available for removal")
			print("DEBUG: Checking why no people are removable...")
			for region in self.regions.values():
				for country_code, country_vals in region.countries.items():
					country_count = len(country_vals["country_people"])
					country_quota = math.ceil(country_vals["country_pc"])
					half_quota = math.ceil(country_quota / 2)
					if country_count > 0:
						print(f"  {country_code}: {country_count} people, quota {country_quota}, half_quota {half_quota}, removable: {country_count > 1 and country_count > half_quota}")
			return
		
		if len(all_removable_people) < countries_needed:
			print(f"Warning: Only {len(all_removable_people)} people can be removed, but need {countries_needed} more countries")
			print("DEBUG: Half-quota protection may be too restrictive")
			countries_needed = len(all_removable_people)
		
		# Get list of countries with 0 people (priority targets)
		countries_with_zero = set()
		for region in self.regions.values():
			for country_code, country_vals in region.countries.items():
				if len(country_vals["country_people"]) == 0:
					countries_with_zero.add(country_code)
		
		print(f"Countries with 0 people available for replacement: {len(countries_with_zero)}")
		
		# Check how many suitable replacements are available before removing anyone
		available_replacements = 0
		replacement_indices = list(range(gca_backups.num_points))
		random.shuffle(replacement_indices)
		
		print(f"Checking {len(replacement_indices)} backup people for suitable replacements...")
		checked_count = 0
		zero_country_candidates = 0
		
		for x in replacement_indices:
			person = gca_backups.get_person(x)
			if person is None:
				continue
			
			checked_count += 1
			
			# Check if this person is from a country with 0 people
			if person["country_iso"] in countries_with_zero:
				zero_country_candidates += 1
				# Check if we can add this person to both systems
				can_add_to_region = False
				can_add_to_bin = False
				
				# For minimum countries enforcement, only check country quota
				# Region and climate risk bin quotas will be enforced in later phases
				if person["country_iso"] in self.country_region:
					person_region = self.country_region[person["country_iso"]]
					region = self.regions[person_region]
					
					# Check country quota only
					country_vals = region.countries[person["country_iso"]]
					country_max = math.ceil(country_vals["country_pc"])
					country_count = len(country_vals["country_people"])
					
					if country_count < country_max:
						can_add_to_region = True
						can_add_to_bin = True  # Assume we can add to any climate risk bin
				
				# Count as available if country quota allows
				if can_add_to_region and can_add_to_bin:
					available_replacements += 1
					print(f"Found suitable replacement {available_replacements}: {person['country']} ({person['country_iso']})")
					if available_replacements >= countries_needed:
						break
				else:
					if debug_print:
						print(f"Cannot add {person['country']} ({person['country_iso']}): region={can_add_to_region}, bin={can_add_to_bin}")
		
		print(f"Checked {checked_count} people, found {zero_country_candidates} from countries with 0 people, {available_replacements} suitable replacements")
		
		# Only remove as many people as we can actually replace
		people_to_remove_count = min(countries_needed, available_replacements)
		print(f"Found {available_replacements} suitable replacements, will remove {people_to_remove_count} people")
		
		if people_to_remove_count == 0:
			print("No suitable replacements available - skipping minimum countries enforcement")
			return
		
		# Shuffle to eliminate any potential clustering bias, then randomly select
		random.shuffle(all_removable_people)
		people_to_remove = random.sample(all_removable_people, people_to_remove_count)
		
		if debug_print:
			# Show which countries are losing people
			removed_by_country = {}
			for person in people_to_remove:
				country = person["country_iso"]
				removed_by_country[country] = removed_by_country.get(country, 0) + 1
			
			print("People removed by country:")
			for country, count in sorted(removed_by_country.items()):
				print(f"  {country}: {count} people")
		
		# Remove people from all systems and add to backup pool
		for person in people_to_remove:
			self._remove_person_from_all_tracking(person, gca_backups)
		
		# Now replace people from backup pool, prioritizing countries with 0 people
		replacements = list(range(gca_backups.num_points))
		random.shuffle(replacements)
		success_replace = 0
		
		for x in replacements:
			if success_replace >= len(people_to_remove):
				break
				
			person = gca_backups.get_person(x)
			if person is None:
				continue
			
			# Prioritize countries with 0 people
			if person["country_iso"] in countries_with_zero:
				# Try to add this person to both systems
				can_add_to_region = False
				can_add_to_bin = False
				
				# Check if we can add to UN region
				if person["country_iso"] in self.country_region:
					person_region = self.country_region[person["country_iso"]]
					region = self.regions[person_region]
					
					# Check country quota only (ignore region and climate risk bin quotas for diversity)
					country_vals = region.countries[person["country_iso"]]
					country_max = math.ceil(country_vals["country_pc"])
					country_count = len(country_vals["country_people"])
					
					if country_count < country_max:
						can_add_to_region = True
						can_add_to_bin = True  # Assume we can add to any climate risk bin for diversity
				
				# Only add if country quota allows (ignore other constraints for diversity)
				if can_add_to_region and can_add_to_bin:
					# Use the proper method to add person to all tracking systems
					self._add_person_to_selection(person)
					
					success_replace += 1
					print(f"Replaced point {success_replace} with {person['country']} (new country)")
		
		print(f"Successfully replaced {success_replace} out of {len(people_to_remove)} people for diversity")
		
		# If we still haven't replaced enough people, try fallback strategy
		if success_replace < len(people_to_remove):
			remaining_to_replace = len(people_to_remove) - success_replace
			print(f"Fallback: Need to replace {remaining_to_replace} more people")
			
			# Try adding people from any country (not just countries with 0 people)
			fallback_replacements = list(range(gca_backups.num_points))
			random.shuffle(fallback_replacements)
			fallback_added = 0
			
			for x in fallback_replacements:
				if fallback_added >= remaining_to_replace:
					break
					
				person = gca_backups.get_person(x)
				if person is None:
					continue
				
				# Check if we can add this person (only country quota constraint)
				if person["country_iso"] in self.country_region:
					person_region = self.country_region[person["country_iso"]]
					region = self.regions[person_region]
					country_vals = region.countries[person["country_iso"]]
					country_max = math.ceil(country_vals["country_pc"])
					country_count = len(country_vals["country_people"])
					
					if country_count < country_max:
						# Add this person (ignore other constraints for diversity)
						self._add_person_to_selection(person)
						fallback_added += 1
						print(f"Fallback added {fallback_added}/{remaining_to_replace}: {person['country']} ({person['country_iso']})")
			
			total_replaced = success_replace + fallback_added
			print(f"Total replacements: {success_replace} (zero countries) + {fallback_added} (fallback) = {total_replaced}/{len(people_to_remove)}")
			
			if total_replaced < len(people_to_remove):
				still_lost = len(people_to_remove) - total_replaced
				print(f"WARNING: Still lost {still_lost} people - no suitable replacements found")
				print(f"Final total: {self.count_selected_people} people")
		
		# Final count
		final_countries = set()
		for region in self.regions.values():
			for country_code, country_vals in region.countries.items():
				if len(country_vals["country_people"]) > 0:
					final_countries.add(country_code)
		
		print(f"Final countries with people: {len(final_countries)}")
	
	def enforce_china_india_balance(self, gca_backups):
		"""Ensure China and India have balanced representation (difference <= 1)"""
		china_count = 0
		india_count = 0
		china_people = []
		india_people = []
		
		# Count current China and India representation
		for region in self.regions.values():
			if "CHN" in region.countries:
				china_people = region.countries["CHN"]["country_people"].copy()
				china_count = len(china_people)
			if "IND" in region.countries:
				india_people = region.countries["IND"]["country_people"].copy()
				india_count = len(india_people)
		
		print(f"Current China representation: {china_count}")
		print(f"Current India representation: {india_count}")
		print(f"Current difference: {abs(china_count - india_count)}")
		
		# If difference is 1 or less, no action needed
		if abs(china_count - india_count) <= 1:
			print("China and India are already balanced (difference <= 1)")
			return
		
		# Determine which country has more people and calculate how many to move
		if china_count > india_count:
			country_to_reduce = "CHN"
			country_to_increase = "IND"
			excess = china_count - india_count
		else:
			country_to_reduce = "IND"
			country_to_increase = "CHN"
			excess = india_count - china_count
		
		# Calculate how many people to move to achieve balance
		# Move half the excess (rounded) to get as close to perfect balance as possible
		people_to_move = round(excess / 2)
		
		print(f"Need to move {people_to_move} people from {country_to_reduce} to {country_to_increase} to achieve balance")
		
		if people_to_move == 0:
			print("No people need to be moved - already balanced")
			return
		
		# Find people to remove from the country with more representation
		people_to_remove = []
		for region in self.regions.values():
			if country_to_reduce in region.countries:
				country_people = region.countries[country_to_reduce]["country_people"]
				# Randomly select people to remove
				people_to_remove = random.sample(country_people, people_to_move)
				break
		
		if not people_to_remove:
			print(f"No people found to remove from {country_to_reduce}")
			return
		
		# Remove the selected people
		print(f"Removing {len(people_to_remove)} people from {country_to_reduce}")
		for person in people_to_remove:
			print(f"Removing person from {person['country_iso']}")
			self._remove_person_from_all_tracking(person, gca_backups)
		
		# Add people from the backup pool to the country with less representation
		people_added = 0
		# Get all backup people and shuffle them
		backup_indices = list(range(gca_backups.num_points))
		random.shuffle(backup_indices)
		
		for x in backup_indices:
			if people_added >= people_to_move:
				break
			
			backup_person = gca_backups.get_person(x)
			if backup_person is None:
				continue
			
			# Check if this backup person is from the target country
			backup_country = backup_person.get("country_iso")
			if backup_country == country_to_increase:
				# Add this person to the selection
				self._add_person_to_selection(backup_person)
				people_added += 1
		
		# Final count
		final_china_count = 0
		final_india_count = 0
		for region in self.regions.values():
			if "CHN" in region.countries:
				final_china_count = len(region.countries["CHN"]["country_people"])
			if "IND" in region.countries:
				final_india_count = len(region.countries["IND"]["country_people"])
		
		print(f"Final China representation: {final_china_count}")
		print(f"Final India representation: {final_india_count}")
		print(f"Final difference: {abs(final_china_count - final_india_count)}")
		print(f"China-India balance enforcement complete. Added {people_added} people from backups")
	
	def _remove_person_from_all_tracking(self, person, gca_backups=None):
		"""Remove a person from all tracking systems and optionally add to backup pool"""
		# Remove from UN region system
		person_region = person["un_region"]
		person_country = person["country_iso"]
		
		if person_region in self.regions and person_country in self.regions[person_region].countries:
			region = self.regions[person_region]
			country_vals = region.countries[person_country]
			if person in country_vals["country_people"]:
				country_vals["country_people"].remove(person)
				region.region_count -= 1
		
		# Remove from climate risk bin system
		for bin_name, bin_obj in self.climate_risk_bins.items():
			if person in bin_obj.bin_people:
				bin_obj.bin_people.remove(person)
				bin_obj.actual_count -= 1
				break
		
		self.count_selected_people -= 1
		
		# Add to backup pool if provided
		if gca_backups is not None:
			gca_backups.add_person_to_backup(person)
	
	def _add_person_to_selection(self, person):
		"""Add a person to all tracking systems"""
		# Store original country code for climate risk bin assignment
		original_country_iso = person["country_iso"]
		
		# Add to UN region system
		person_region = person["un_region"]
		person_country = person["country_iso"]
		
		if person_region in self.regions and person_country in self.regions[person_region].countries:
			region = self.regions[person_region]
			region.add_person_to_region(person)
		
		# Add to climate risk bin system using original country code
		bin_assigned = False
		for bin_name, bin_obj in self.climate_risk_bins.items():
			# Skip the "None" bin for now, try specific bins first
			if bin_name == "Climate Risk Bin None":
				continue
			# Use original country code for climate risk bin assignment
			if original_country_iso in bin_obj.countries_in_bin:
				bin_obj.actual_count += 1
				person["climate_risk_bin"] = bin_name  # Set the bin name
				bin_obj.bin_people.append(person)
				bin_assigned = True
				break
		
		# If not assigned to any specific bin, assign to "None" bin
		if not bin_assigned:
			none_bin = self.climate_risk_bins["Climate Risk Bin None"]
			none_bin.actual_count += 1
			person["climate_risk_bin"] = "Climate Risk Bin None"
			none_bin.bin_people.append(person)
		
		self.count_selected_people += 1
	
	def _verify_total_count(self, phase_name, stop_on_mismatch=True):
		"""Verify that the tracked count matches the actual count"""
		actual_count = 0
		region_breakdown = {}
		for region_name, region in self.regions.items():
			actual_count += region.region_count
			region_breakdown[region_name] = region.region_count
		
		# Also verify climate risk bin counts
		climate_bin_count = 0
		climate_breakdown = {}
		for bin_name, bin_obj in self.climate_risk_bins.items():
			climate_bin_count += bin_obj.actual_count
			climate_breakdown[bin_name] = bin_obj.actual_count
		
		print(f"VERIFICATION {phase_name}:")
		print(f"  Tracked count = {self.count_selected_people}")
		print(f"  Region count = {actual_count}")
		print(f"  Climate bin count = {climate_bin_count}")
		
		all_match = (self.count_selected_people == actual_count == climate_bin_count)
		
		if not all_match:
			print(f"ERROR: Count mismatch detected in {phase_name}!")
			print(f"  Region breakdown: {region_breakdown}")
			print(f"  Climate bin breakdown: {climate_breakdown}")
			if stop_on_mismatch:
				print(f"STOPPING EXECUTION - PEOPLE LOST DURING {phase_name}")
				exit(1)
		else:
			print(f"   All counts match!")
		
		return actual_count




gca_people = ca_people(total_pop, num_points, True)
if debug_print:
	print("And backup people...")

# Ensure backup points use different random numbers for true independence
if RANDOM_SEED is not None:
    # Use a different seed for backups to ensure independence
    random.seed(RANDOM_SEED + 1000)  # Offset the seed
else:
    # For truly random selection, this will happen automatically
    pass

gca_backups = ca_people(total_pop, 4*num_points, False)

# Now manually override the backup object's random numbers to ensure independence
if RANDOM_SEED is not None:
    # Generate completely different random numbers for backups
    random.seed(RANDOM_SEED + 2000)  # Different offset
    gca_backups.selected_nums = []
    for i in range(gca_backups.num_points):
        gca_backups.selected_nums.append(random.randint(1, ca_people.total_pop))
    gca_backups.selected_nums.sort()
    print("Generated independent random numbers for backup selection")
else:
    # For truly random selection, generate fresh numbers
    gca_backups.selected_nums = []
    for i in range(gca_backups.num_points):
        gca_backups.selected_nums.append(random.randint(1, ca_people.total_pop))
    gca_backups.selected_nums.sort()
    print("Generated fresh random numbers for backup selection")

# Debug: Show the range of random numbers for both selections
if debug_print:
    print(f"Initial selection random numbers range: {min(gca_people.selected_nums):,} to {max(gca_people.selected_nums):,}")
    print(f"Backup selection random numbers range: {min(gca_backups.selected_nums):,} to {max(gca_backups.selected_nums):,}")
    print(f"Total population: {ca_people.total_pop:,}")
    
    # Check for overlap in random numbers
    initial_set = set(gca_people.selected_nums)
    backup_set = set(gca_backups.selected_nums)
    overlap = len(initial_set.intersection(backup_set))
    print(f"Overlap in random numbers: {overlap} out of {len(initial_set)}")
    


# Memory-efficient data loading and shuffling
print("Loading and shuffling data for unbiased selection...")

# Essential columns only to minimize memory usage - these are the ONLY columns actually used in the code
essential_columns = ['UN_2020_E', 'ISOALPHA', 'COUNTRYNM', 'CENTROID_X', 'CENTROID_Y', 'TOTAL_A_KM', 'NAME1', 'NAME2', 'NAME3', 'NAME4', 'NAME5', 'NAME6']

# Collect data from all files with memory optimization
all_data = []
total_rows = 0

for i, file_name in enumerate(global_pop_admin_centroids_files):
    print(f"Loading file {i+1}/{len(global_pop_admin_centroids_files)}: {file_name}...")
    
    # Read only essential columns and optimize data types
    df = pd.read_csv(global_pop_admin_centroids_file_root + "\\" + file_name, 
                     usecols=essential_columns,
                     dtype={
                         'UN_2020_E': 'int32',  # Population count
                         'ISOALPHA': 'category',  # Country codes
                         'COUNTRYNM': 'category',  # Country names
                         'CENTROID_X': 'float32',  # Longitude
                         'CENTROID_Y': 'float32',  # Latitude
                         'TOTAL_A_KM': 'float32',  # Area
                         'NAME1': 'category',  # Admin names
                         'NAME2': 'category',
                         'NAME3': 'category',
                         'NAME4': 'category',
                         'NAME5': 'category',
                         'NAME6': 'category'
                     })
    
    # Filter out rows with zero population to save memory
    df = df[df['UN_2020_E'] > 0].copy()
    
    all_data.append(df)
    total_rows += len(df)
    print(f"  Loaded {len(df):,} rows from {file_name} (total so far: {total_rows:,})")

print(f"\nAll files loaded. Total rows: {total_rows:,}")

# Combine all data
print("Combining data from all files...")
combined_df = pd.concat(all_data, ignore_index=True)
del all_data  # Free memory from individual file data

print(f"Total rows: {len(combined_df):,}")
print(f"Memory usage: {combined_df.memory_usage(deep=True).sum() / 1024**3:.2f} GB")

# Shuffle all rows randomly to eliminate geographic clustering bias
print("Shuffling rows to eliminate geographic clustering bias...")
if RANDOM_SEED is not None:
    print(f"Using fixed random seed: {RANDOM_SEED} (for testing only!)")
    combined_df = combined_df.sample(frac=1, random_state=RANDOM_SEED).reset_index(drop=True)
    random.seed(RANDOM_SEED)  # Set random seed for consistent results
else:
    print("Using truly random selection (no fixed seed)")
    combined_df = combined_df.sample(frac=1).reset_index(drop=True)

# Convert to list of dictionaries for processing (more memory efficient than keeping as DataFrame)
print("Converting to processing format...")
shuffled_rows = combined_df.to_dict('records')
# Keep combined_df for backup processing - will delete after both selections are complete

# Two-phase selection if SIDS guarantee is enabled
if ENABLE_SIDS_GUARANTEE and sids_countries:
    print(f"\n=== TWO-PHASE SELECTION WITH SIDS GUARANTEE ===")
    print(f"SIDS percentage target: {SIDS_PERCENTAGE:.1%}")
    
    # Phase 1: Select SIDS points first
    sids_points_target = int(num_points * SIDS_PERCENTAGE)
    remaining_points = num_points - sids_points_target
    
    print(f"Phase 1: Selecting {sids_points_target} points from SIDS countries")
    print(f"Phase 2: Selecting {remaining_points} points from remaining countries")
    
    # Split data into SIDS and non-SIDS, applying population threshold
    sids_rows = []
    non_sids_rows = []
    sids_pop = 0
    non_sids_pop = 0
    sids_countries_above_threshold = set()
    sids_countries_below_threshold = set()
    
    # First pass: calculate total population per SIDS country
    sids_country_populations = {}
    for row in shuffled_rows:
        if row["ISOALPHA"] in sids_countries:
            country_code = row["ISOALPHA"]
            if country_code not in sids_country_populations:
                sids_country_populations[country_code] = 0
            sids_country_populations[country_code] += int(row["UN_2020_E"])
    
    # Categorize SIDS countries by population threshold
    for country_code, total_pop in sids_country_populations.items():
        if total_pop < SIDS_POPULATION_THRESHOLD:
            sids_countries_below_threshold.add(country_code)
        else:
            sids_countries_above_threshold.add(country_code)
    
    print(f"SIDS countries below threshold ({SIDS_POPULATION_THRESHOLD:,}): {len(sids_countries_below_threshold)}")
    print(f"SIDS countries above threshold: {len(sids_countries_above_threshold)}")
    if sids_countries_above_threshold:
        print(f"  Above threshold: {sorted(list(sids_countries_above_threshold))}")
    
    # Second pass: split data based on threshold
    for row in shuffled_rows:
        if row["ISOALPHA"] in sids_countries:
            if row["ISOALPHA"] in sids_countries_below_threshold:
                sids_rows.append(row)
                sids_pop += int(row["UN_2020_E"])
            else:
                # SIDS countries above threshold are treated as non-SIDS
                non_sids_rows.append(row)
                non_sids_pop += int(row["UN_2020_E"])
        else:
            non_sids_rows.append(row)
            non_sids_pop += int(row["UN_2020_E"])
    
    print(f"SIDS data (below threshold): {len(sids_rows):,} rows, {sids_pop:,} population")
    print(f"Non-SIDS data (including SIDS above threshold): {len(non_sids_rows):,} rows, {non_sids_pop:,} population")
    
    # Phase 1: Select from SIDS using cumulative population approach
    print("\n--- Phase 1: SIDS Selection ---")
    print(f"SIDS points target: {sids_points_target}")
    print(f"SIDS population: {sids_pop:,}")
    
    # Check if we have enough SIDS population
    if sids_pop == 0:
        print("WARNING: No SIDS countries below population threshold found!")
        print(f"All SIDS countries have population >= {SIDS_POPULATION_THRESHOLD:,}")
        print("Available SIDS countries:", list(sids_countries)[:10])
        print("SIDS countries above threshold:", sorted(list(sids_countries_above_threshold)))
        print("Falling back to standard single-phase selection...")
        
        # Disable SIDS guarantee and proceed with normal selection
        ENABLE_SIDS_GUARANTEE = False
        sids_points_target = 0
        remaining_points = num_points
    else:
        # Generate SIDS-specific random numbers for the SIDS population range
        sids_random_nums = []
        for i in range(sids_points_target):
            sids_random_nums.append(random.randint(1, sids_pop))
        sids_random_nums.sort()
    
    if sids_pop > 0:  # Only proceed with SIDS selection if there are SIDS countries below threshold
        if debug_print:
            print(f"SIDS random numbers: {sids_random_nums[:5]}... (total: {len(sids_random_nums)})")
            print(f"SIDS population range: 1 to {sids_pop:,}")
        
        # Temporarily override the selection parameters for SIDS selection
        original_random_nums = gca_people.selected_nums.copy()
        original_num_points = gca_people.num_points
        
        gca_people.selected_nums = sids_random_nums
        gca_people.num_points = sids_points_target
        
        # Use the existing cumulative population method with SIDS data
        pop_count = 0
        for row in sids_rows:
            pop_row = int(row["UN_2020_E"])
            if debug_print:
                print(f"Processing SIDS row: {row['COUNTRYNM']} ({row['ISOALPHA']}) - Pop: {pop_row:,}")
            
            gca_people.grab_people_in_admin_area(pop_count, row)
            pop_count += pop_row
            
            # Progress indicator
            if pop_count % 1000000 == 0:
                print(f"SIDS population count: {pop_count:,}", end="\r")
        
    print(f"\nSIDS selection complete: {gca_people.count_selected_people} points")
    sids_actual_count = gca_people.count_selected_people
    
    # CRITICAL: Verify SIDS selection didn't lose anyone
    print("\n=== VERIFYING SIDS SELECTION ===")
    gca_people._verify_total_count("After SIDS Selection")
    if gca_people.count_selected_people != sids_actual_count:
        print(f"ERROR: SIDS selection verification failed! Expected {sids_actual_count}, got {gca_people.count_selected_people}")
        print("STOPPING EXECUTION - PEOPLE LOST DURING SIDS SELECTION")
        exit(1)
    
    # Restore original selection parameters for Phase 2
    gca_people.selected_nums = original_random_nums
    gca_people.num_points = original_num_points
    
    # Phase 2: Select from remaining countries with adjusted quotas
    print("\n--- Phase 2: Non-SIDS Selection ---")
    
    if sids_actual_count > 0:  # Only adjust quotas if SIDS selection happened
        print("Adjusting quotas for remaining selection...")
        
        # Adjust quotas for remaining points
        for region in gca_people.regions.values():
            for country_vals in region.countries.values():
                if country_vals["country_pc"] > 0:
                    # Scale down quota proportionally
                    country_vals["country_pc"] = country_vals["country_pc"] * (remaining_points / num_points)
        
        # Adjust climate risk bin quotas
        for bin_name, bin_obj in gca_people.climate_risk_bins.items():
            # Skip the "None" bin as it has no quota limitations
            if bin_name == "Climate Risk Bin None":
                continue
            if bin_obj.quota_max > 0:
                bin_obj.quota_max = int(bin_obj.quota_max * (remaining_points / num_points))
    else:
        print("No quota adjustment needed - using original quotas")
    
    # Continue selection from non-SIDS data
    print(f"Phase 2: Need {remaining_points} more points to reach {num_points} total")
    print(f"Already selected {gca_people.count_selected_people} SIDS points")
    
    # Generate new random numbers for Phase 2 (remaining points only)
    # Keep the original count and just add more people
    phase2_random_nums = []
    for i in range(remaining_points):
        phase2_random_nums.append(random.randint(1, ca_people.total_pop))
    phase2_random_nums.sort()
    
    print(f"Phase 2: Generated {len(phase2_random_nums)} random numbers")
    print(f"Phase 2: Random number range: 1 to {ca_people.total_pop:,}")
    print(f"Phase 2: Max random number: {max(phase2_random_nums):,}")
    print(f"Phase 2: Min random number: {min(phase2_random_nums):,}")
    
    # Temporarily store original selection parameters
    original_selected_nums = gca_people.selected_nums.copy()
    original_num_points = gca_people.num_points
    
    # Set Phase 2 parameters
    # We need to pad the selected_nums array to account for SIDS people already selected
    # The grab_people_in_admin_area function uses count_selected_people as an index
    # So we need to pad with dummy values for the first sids_actual_count positions
    padded_random_nums = [0] * sids_actual_count + phase2_random_nums
    gca_people.selected_nums = padded_random_nums
    # Set num_points to the total target (SIDS + remaining)
    gca_people.num_points = num_points
    
    # Use the original shuffled data (which includes both SIDS and non-SIDS)
    pop_count = 0
    for row in shuffled_rows:
        pop_row = int(row["UN_2020_E"])
        gca_people.grab_people_in_admin_area(pop_count, row)
        pop_count += pop_row
        
        # Progress indicator
        if pop_count % 1000000 == 0:
            print(f"Phase 2 population count: {pop_count:,}", end="\r")
    
    # Restore the original num_points
    gca_people.num_points = original_num_points
    
    print(f"\nNon-SIDS selection complete. Population count: {pop_count:,}")
    print(f"Phase 2 selected {gca_people.count_selected_people - sids_actual_count} additional points")
    non_sids_actual_count = gca_people.count_selected_people - sids_actual_count
    
    # CRITICAL: Verify Phase 2 selection didn't lose anyone
    print("\n=== VERIFYING PHASE 2 SELECTION ===")
    gca_people._verify_total_count("After Phase 2 Selection")
    expected_total = sids_actual_count + non_sids_actual_count
    if gca_people.count_selected_people != expected_total:
        print(f"ERROR: Phase 2 selection verification failed!")
        print(f"Expected total: {expected_total} (SIDS: {sids_actual_count} + Non-SIDS: {non_sids_actual_count})")
        print(f"Actual total: {gca_people.count_selected_people}")
        print("STOPPING EXECUTION - PEOPLE LOST DURING PHASE 2 SELECTION")
        exit(1)
    
    # Restore original selection parameters
    gca_people.selected_nums = original_selected_nums
    gca_people.num_points = original_num_points
    
    print(f"\n=== SELECTION SUMMARY ===")
    print(f"SIDS Phase: {sids_actual_count} points (target: {sids_points_target})")
    print(f"Non-SIDS Phase: {non_sids_actual_count} points (target: {remaining_points})")
    print(f"Total: {gca_people.count_selected_people} points (target: {num_points})")
    
    # IMPORTANT: Restore original global quotas after SIDS selection
    # The SIDS adjustment was only for Phase 2 selection, but final quotas should be original
    print("Restoring original global quotas for final enforcement...")
    
    # Simply restore the original quotas without resetting people
    # Re-load original quotas from the already loaded data
    all_rows = un_region_df.to_dict('records')
    all_rows.sort(key=lambda x: (x["parent_country_code"], x["country_code"]))
    
    # Reset region quotas to original values (but keep the people!)
    for region in gca_people.regions.values():
        region.region_pop_percent = 0.0
        # Don't reset region_count or countries - keep the people!
    
    # Update country quotas without recreating countries (preserve existing people)
    for row in all_rows:
        country_percent = float(row["country_pop_percent"])
        country_code = row["country_code"]
        parent_country_code = row["parent_country_code"]
        region_name = row["un_region"]
        
        if region_name in gca_people.regions:
            region = gca_people.regions[region_name]
            
            # Update the quota for this country if it exists
            if country_code in region.countries:
                region.countries[country_code]["country_pc"] = num_points * country_percent / 100.0
                region.region_pop_percent += num_points * country_percent / 100.0
            else:
                # If country doesn't exist, create it (this shouldn't happen normally)
                if debug_print:
                    print(f"Warning: Country {country_code} not found in region {region_name}, creating it")
                region.add_country_to_region(country_code, parent_country_code, num_points * country_percent / 100.0)
    
    # Restore original climate risk bin quotas
    for i, row in climate_risk_caps.head(len(climate_risk_caps) - 1).iterrows():
        bin_name = f"Climate Risk Bin {i+1}"
        if bin_name in gca_people.climate_risk_bins:
            quota_proportion = row['boosted_counts']
            gca_people.climate_risk_bins[bin_name].quota_max = math.ceil(quota_proportion * num_points)
    
    print("Original global quotas restored for final enforcement.")
    
    # CRITICAL: Verify all counts are correct after restoration
    print("\n=== VERIFYING COUNTS AFTER SIDS RESTORATION ===")
    gca_people._verify_total_count("After SIDS Restoration")
    
    # Verify we didn't lose anyone during quota restoration
    if gca_people.count_selected_people != expected_total:
        print(f"ERROR: Quota restoration verification failed!")
        print(f"Expected total: {expected_total} (before restoration)")
        print(f"Actual total: {gca_people.count_selected_people} (after restoration)")
        print("STOPPING EXECUTION - PEOPLE LOST DURING QUOTA RESTORATION")
        exit(1)
    
    print("=== SIDS RESTORATION VERIFICATION COMPLETE ===")
    
else:
    # Standard single-phase selection (original logic)
    # Set variables for consistency with SIDS case
    sids_actual_count = 0
    non_sids_actual_count = num_points
    expected_total = num_points
    sids_points_target = 0
    remaining_points = num_points
    
    print("Processing shuffled data for initial selection...")
    pop_count = 0
    for row in shuffled_rows:
        pop_row = int(row["UN_2020_E"])
        # there might be more than one person we want in here!! the next number could even be the same number...
        gca_people.grab_people_in_admin_area(pop_count, row)
        pop_count += pop_row
        
        # Progress indicator
        if pop_count % 1000000 == 0:
            print(f"Population count: {pop_count:,}", end="\r")

    print(f"\nInitial selection complete. Population count: {pop_count:,}")
    
    # CRITICAL: Verify initial selection didn't lose anyone
    print("\n=== VERIFYING INITIAL SELECTION ===")
    gca_people._verify_total_count("After Initial Selection")

# Now process for backup points with a fresh shuffle for true independence
print("Processing shuffled data for backup points...")
# Use existing data but with fresh shuffle - much more efficient
if RANDOM_SEED is not None:
    # Use a different seed for backup selection
    backup_df = combined_df.sample(frac=1, random_state=RANDOM_SEED + 1000).reset_index(drop=True)
else:
    # Fresh random shuffle for backups
    backup_df = combined_df.sample(frac=1).reset_index(drop=True)

backup_rows = backup_df.to_dict('records')
del backup_df

# If SIDS guarantee is enabled, also apply it to backup selection
if ENABLE_SIDS_GUARANTEE and sids_countries:
    print("Applying SIDS guarantee to backup selection...")
    
    # Calculate SIDS country populations for backup data
    backup_sids_country_populations = {}
    for row in backup_rows:
        if row["ISOALPHA"] in sids_countries:
            country_code = row["ISOALPHA"]
            if country_code not in backup_sids_country_populations:
                backup_sids_country_populations[country_code] = 0
            backup_sids_country_populations[country_code] += int(row["UN_2020_E"])
    
    # Categorize SIDS countries by population threshold for backup
    backup_sids_countries_below_threshold = set()
    for country_code, total_pop in backup_sids_country_populations.items():
        if total_pop < SIDS_POPULATION_THRESHOLD:
            backup_sids_countries_below_threshold.add(country_code)
    
    print(f"Backup SIDS countries below threshold: {len(backup_sids_countries_below_threshold)}")
    
    # Split backup data into SIDS (below threshold) and non-SIDS
    sids_backup_rows = []
    non_sids_backup_rows = []
    
    for row in backup_rows:
        if row["ISOALPHA"] in sids_countries and row["ISOALPHA"] in backup_sids_countries_below_threshold:
            sids_backup_rows.append(row)
        else:
            non_sids_backup_rows.append(row)
    
    # Shuffle both sets independently
    random.shuffle(sids_backup_rows)
    random.shuffle(non_sids_backup_rows)
    
    # Reconstruct backup_rows with SIDS first, then non-SIDS
    backup_rows = sids_backup_rows + non_sids_backup_rows

pop_count = 0
backup_selections_made = 0
for row in backup_rows:
    pop_row = int(row["UN_2020_E"])
    gca_backups.grab_people_in_admin_area(pop_count, row)
    pop_count += pop_row
    
    # Progress indicator
    if pop_count % 1000000 == 0:
        print(f"Backup population count: {pop_count:,}", end="\r")

print(f"\nBackup selection complete. Population count: {pop_count:,}")

# CRITICAL: Verify backup selection didn't lose anyone
print("\n=== VERIFYING BACKUP SELECTION ===")
gca_people._verify_total_count("After Backup Selection", stop_on_mismatch=False)  # Don't stop for backups

# Now we can free the DataFrame memory
del combined_df

print("Check total population (post selection) = {}".format(total_pop))

# Show SIDS representation summary if enabled
if ENABLE_SIDS_GUARANTEE and sids_countries:
    print("\n=== SIDS REPRESENTATION SUMMARY ===")
    sids_count = 0
    for region in gca_people.regions.values():
        for country_vals in region.countries.values():
            for person in country_vals["country_people"]:
                if person.get("country_iso") in sids_countries:
                    sids_count += 1
    
    actual_percentage = (sids_count / num_points) * 100
    target_percentage = SIDS_PERCENTAGE * 100
    print(f"Target SIDS percentage: {target_percentage:.1f}%")
    print(f"Actual SIDS percentage: {actual_percentage:.1f}%")
    print(f"SIDS points selected: {sids_count}/{num_points}")
    print(f"Target achieved: {'' if abs(actual_percentage - target_percentage) < 1 else ''}")

# calculate the distance to the closet other point for every point, and sum these minimum distances
#gca_people.selected_people_min_dist()

# Create visualizations BEFORE quota enforcement
print("\n" + "="*60)
print("CREATING VISUALIZATIONS")
print("="*60)

# 1. Map of initial selection vs backup points (before quota enforcement)
print("1. Creating map of initial selection vs backup points...")
make_initial_vs_backup_map(gca_people, gca_backups, "Initial Selection (Green) vs Backup Points (Blue) - Before Quota Enforcement", 
                          highlight_sids=ENABLE_SIDS_GUARANTEE)

# 2. Bar charts showing initial quotas vs actual amounts
print("2. Creating initial quota comparison charts...")
make_quota_charts(gca_people)

# 2b. Map colored by climate risk bin
print("2b. Creating map colored by climate risk bin...")
make_map(gca_people, "Initial Selection - Colored by Climate Risk Bin", color_col='climate_risk_bin')

# Collect SIDS countries data BEFORE quota enforcement (if SIDS is enabled)
sids_summary_before = {}
if ENABLE_SIDS_GUARANTEE and sids_countries:
    sids_summary_before = get_sids_countries_summary(gca_people, sids_countries)

# Now enforce quotas
print("\n=== STARTING QUOTA ENFORCEMENT ===")
gca_people.replace_above_max(gca_backups)

# CRITICAL: Final verification after all quota enforcement
print("\n=== FINAL VERIFICATION AFTER ALL QUOTA ENFORCEMENT ===")
gca_people._verify_total_count("Final Verification")

# 3. Map of final selection (after quota enforcement)
print("3. Creating map of final selection...")
make_map(gca_people, "Final Selection - Points After Quota Enforcement")

# 4. Bar charts showing final quotas vs actual amounts
print("4. Creating final quota comparison charts...")
make_quota_charts(gca_people)

# 4b. Map colored by climate risk bin (final)
print("4b. Creating final map colored by climate risk bin...")
make_map(gca_people, "Final Selection - Colored by Climate Risk Bin", color_col='climate_risk_bin')

# Collect SIDS countries data AFTER quota enforcement and display comparison table
if ENABLE_SIDS_GUARANTEE and sids_countries:
    sids_summary_after = get_sids_countries_summary(gca_people, sids_countries)
    print_sids_countries_table(sids_summary_before, sids_summary_after, sids_countries)

gca_people.selected_people_print()

print("\nVisualization complete! Check the generated maps and charts above.")
print("="*60)
# print a table of countries and the number of people selected
# print("Countries and the number of people selected:")
# total_people = 0
# for region in gca_people.regions.values():
# 	for country_code, country_vals in region.countries.items():
# 		total_people += len(country_vals['country_people'])
# 		print(f"{country_code}: {len(country_vals['country_people'])}")
print("--------------------------------")
print("Total number of people selected: {}".format(gca_people.count_selected_people))



